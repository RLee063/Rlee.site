<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans" >
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="操作系统," />










<meta name="description" content="第十章 32位x86处理器编程架构10.1 IA-32架构的基本执行环境略 10.2 线代处理器的结构和特点10.2.1 流水线为了提高处理器的执行效率和速度，可以把一条指令的执行过程分解为若干个细小的步骤，并分配给相应的单元来完成。各个单元独立、并行执行，这种执行指令的方法就是流水线技术。  10.2.2 cache高速缓存高速缓存是处理器与内存之间的一个静态存储器，用于缓解处理器速度和内存读写">
<meta name="keywords" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="&lt;从实模式到保护模式&gt;笔记">
<meta property="og:url" content="http://yoursite.com/2018/06/08/x86汇编语言笔记/index.html">
<meta property="og:site_name" content="Lee&#39;s blog">
<meta property="og:description" content="第十章 32位x86处理器编程架构10.1 IA-32架构的基本执行环境略 10.2 线代处理器的结构和特点10.2.1 流水线为了提高处理器的执行效率和速度，可以把一条指令的执行过程分解为若干个细小的步骤，并分配给相应的单元来完成。各个单元独立、并行执行，这种执行指令的方法就是流水线技术。  10.2.2 cache高速缓存高速缓存是处理器与内存之间的一个静态存储器，用于缓解处理器速度和内存读写">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/10_1.png">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/10_2.png">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/10_3.png">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/11_1.png">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/11_2.png">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/11_3.png">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/11_5.png">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/11_4.png">
<meta property="og:updated_time" content="2018-06-11T03:00:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="&lt;从实模式到保护模式&gt;笔记">
<meta name="twitter:description" content="第十章 32位x86处理器编程架构10.1 IA-32架构的基本执行环境略 10.2 线代处理器的结构和特点10.2.1 流水线为了提高处理器的执行效率和速度，可以把一条指令的执行过程分解为若干个细小的步骤，并分配给相应的单元来完成。各个单元独立、并行执行，这种执行指令的方法就是流水线技术。  10.2.2 cache高速缓存高速缓存是处理器与内存之间的一个静态存储器，用于缓解处理器速度和内存读写">
<meta name="twitter:image" content="http://yoursite.com/images/从实模式到保护模式/10_1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/08/x86汇编语言笔记/"/>





  <title><从实模式到保护模式>笔记 | Lee's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans" style="background-image: url(/images/bg1.jpeg); background-attachment: fixed ">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Lee's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/08/x86汇编语言笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lee's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"><从实模式到保护模式>笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-08T12:00:00+09:00">
                2018-06-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第十章-32位x86处理器编程架构"><a href="#第十章-32位x86处理器编程架构" class="headerlink" title="第十章 32位x86处理器编程架构"></a>第十章 32位x86处理器编程架构</h1><h2 id="10-1-IA-32架构的基本执行环境"><a href="#10-1-IA-32架构的基本执行环境" class="headerlink" title="10.1 IA-32架构的基本执行环境"></a>10.1 IA-32架构的基本执行环境</h2><p>略</p>
<h2 id="10-2-线代处理器的结构和特点"><a href="#10-2-线代处理器的结构和特点" class="headerlink" title="10.2 线代处理器的结构和特点"></a>10.2 线代处理器的结构和特点</h2><h3 id="10-2-1-流水线"><a href="#10-2-1-流水线" class="headerlink" title="10.2.1 流水线"></a>10.2.1 流水线</h3><p>为了提高处理器的执行效率和速度，可以把一条指令的执行过程分解为若干个细小的步骤，并分配给相应的单元来完成。各个单元独立、并行执行，这种执行指令的方法就是流水线技术。</p>
<p><img src="/images/从实模式到保护模式/10_1.png" alt=""></p>
<h3 id="10-2-2-cache高速缓存"><a href="#10-2-2-cache高速缓存" class="headerlink" title="10.2.2 cache高速缓存"></a>10.2.2 cache高速缓存</h3><p>高速缓存是处理器与内存之间的一个静态存储器，用于缓解处理器速度和内存读写速度不匹配的问题。<br>程序运行时往往具有空间局部性，频繁的访问相邻内存的指令和数据。利用这个特性可以把处理器正在访问的内存调出来放在高速缓存中，每次访问内存时首先从高速缓存中检索。</p>
<p><img src="/images/从实模式到保护模式/10_2.png" alt=""></p>
<p>有关高速缓存的更多知识，例如高速缓存算法以及不中惩罚，请移步《深入理解计算机系统》笔记。</p>
<h3 id="10-2-3-乱序执行"><a href="#10-2-3-乱序执行" class="headerlink" title="10.2.3 乱序执行"></a>10.2.3 乱序执行</h3><p><code>支持乱序执行，怎么保证指令的原子性？</code></p>
<p><code>实现上述流水线操作不需要拆分指令？</code></p>
<p>为了实现流水线操作，需要把指令拆分为更小的微操作（micro-operations），例如对寄存器进行操作、访问内存等。这样处理器在适当的时候乱序执行指令就可以提高处理器效率。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [mem1]</span><br><span class="line">shl eax, <span class="number">5</span></span><br><span class="line">add eax, [mem2]</span><br><span class="line">mov [mem3], eax</span><br></pre></td></tr></table></figure>
<p>第三条指令可以分解为从内存中读取mem2的数值，把eax加上这个数值两个微操作，在执行第二条指令的时候就可以提前从内存中读取mem2的数值。</p>
<h3 id="10-2-4-寄存器重命名"><a href="#10-2-4-寄存器重命名" class="headerlink" title="10.2.4 寄存器重命名"></a>10.2.4 寄存器重命名</h3><p><code>感觉这一个特性是为了乱序执行服务的</code></p>
<p><code>具体算法是怎么实现的？</code></p>
<p>处理器通过对寄存器换名的方式（<code>具体算法书上没有提到，好像是tomasulo算法</code>）来避免WAR（读后写）和WAW（写后写）带来的流水线停顿。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [mem1]</span><br><span class="line">shl eax, <span class="number">3</span></span><br><span class="line">mov [mem2], eax</span><br><span class="line">mov eax, [mem3]</span><br><span class="line">add eax, <span class="number">2</span></span><br><span class="line">mov [mem4], eax</span><br></pre></td></tr></table></figure>
<p>很明显前三条指令与后三条指令没有关系，但是因为使用了相同的寄存器所以后三条指令必须等待eax释放之后才能执行，通过对后三条指令eax寄存器换名的方式，就可以对上述代码乱序执行。</p>
<h3 id="10-2-5-分支目标预测"><a href="#10-2-5-分支目标预测" class="headerlink" title="10.2.5 分支目标预测"></a>10.2.5 分支目标预测</h3><p>流水线最大的问题就是代码中存在大量分支，例如if语句随时可能让指令流前往任意方向。当遇到转移指令时，后面已经进入流水线的指令都会失效，必须清空流水线，这个代价显然太大了，所以就需要对分支目标进行预测。</p>
<p>从统计学的角度来看，有些事情一旦出现，下一次出现的概率还是很大，例如while循环。在处理器内部，有一个小容量的分支目标缓存器，当处理器执行了一条分支语句之后，在缓存器中就会记录当前指令的地址，分支目标地址，以及本次预测分支的结果。下次再执行到这个分支，处理器就会通过缓存器中的对应条目，预测执行和上一次相同的分支。但如果预测失败了，那么清空流水线，刷新缓存器中的记录，这个代价就比较大。</p>
<p><img src="/images/从实模式到保护模式/10_3.png" alt=""></p>
<h2 id="10-3-32位模式的指令系统"><a href="#10-3-32位模式的指令系统" class="headerlink" title="10.3 32位模式的指令系统"></a>10.3 32位模式的指令系统</h2><p>略</p>
<h1 id="第十一章-进入保护模式"><a href="#第十一章-进入保护模式" class="headerlink" title="第十一章 进入保护模式"></a>第十一章 进入保护模式</h1><h2 id="全局描述符表GDT"><a href="#全局描述符表GDT" class="headerlink" title="全局描述符表GDT"></a>全局描述符表GDT</h2><p>分段模式下需要控制对段的访问，就需要记录下与段相关的信息，每一条记录这样信息的数据结构被称为段描述符（Segment Descriptor），为了存放这些描述符，需要在内存中开辟一个段描述符表。其中最主要的描述符表是全局描述符表（Global Descriptor Table），进入保护模式之前必须要定义全局描述符表。</p>
<p>在进入保护模式之前，处理器必须要知道全局描述符表的位置，为此专门有一个48位寄存器GDTR来存放全局描述符表的信息。</p>
<p><img src="/images/从实模式到保护模式/11_1.png" alt=""></p>
<p>边界数值等于表大小-1，也就是最后一个字节的偏移量。</p>
<p>因为在进入保护模式之前处理器寻址能力只有1MB，所以GDT定义在1MB空间以内，进入保护模式之后可以迁移。</p>
<h2 id="存储器的段描述符"><a href="#存储器的段描述符" class="headerlink" title="存储器的段描述符"></a>存储器的段描述符</h2><p>每个段描述符占八个字节。结构如下：</p>
<p><img src="/images/从实模式到保护模式/11_2.png" alt=""></p>
<p><code>地址被拆开了是历史遗留问题</code></p>
<p>G 位是粒度，用于解释段界限的含义。如果为0则段界限以byte为单位，如果为1则段界限以4kbytes为单位。</p>
<p>D/B 是默认操作数大小/默认桟指针大小或者上部边界。对于代码段，0表示16bits，1表示32bits。对于桟段指明了用SP还是用ESP，上部边界是0XFFFF还是0XFFFFFFFF。</p>
<p>L 是64位代码段标志。</p>
<p>AVL 是保留给软件的位。</p>
<p>P 是段存在位，即是否在内存中。</p>
<p>DPL 是特权级位，用于限制访问。</p>
<p>S 位指定描述符类型，0代表系统段，1代表数据段或者代码段。</p>
<p>TYPE 指示段的属性，数据段和代码段定义不同：</p>
<p><img src="/images/从实模式到保护模式/11_3.png" alt=""></p>
<p>X 代表是否可执行，E 代表数据扩展方向，W 代表是否可写，A 代表最近是否访问。C 代表是否为特权级依从的（是否是一致代码段），R 代表是否是可读的。</p>
<pre><code>个人理解一致非一致代码段就是用来保护系统内核代码的。

1.一致代码段：用户代码可以访问的内核代码，但是内核代码不允许访问用户代码。
2.非一致代码段：只允许同级代码段访问。
</code></pre><p><img src="/images/从实模式到保护模式/11_5.png" alt=""></p>
<h2 id="安装存储器的段描述符并加载GDTR"><a href="#安装存储器的段描述符并加载GDTR" class="headerlink" title="安装存储器的段描述符并加载GDTR"></a>安装存储器的段描述符并加载GDTR</h2><p>GDT的第一个描述符必须是空描述符，毕竟经常会出错把啥啥啥变为0x00000000。<br>lgdt 是把全局描述符表的信息装载到GDTR里面的汇编指令。</p>
<h2 id="A20地址线"><a href="#A20地址线" class="headerlink" title="A20地址线"></a>A20地址线</h2><p>进入保护模式之前还有一个历史遗留问题。</p>
<p>以前最多能访问1MB，只需要20个地址引脚，那么第21个地址引脚就会出现点问题。只有20根地址引脚的时候访问超过0XFFFFF的时候就会变为0x100000，但没有1的地址引脚啊，所以就变成0x0000了。现在有了这个引脚，解决方案暂时是令其衡为零。</p>
<p>可以通过92号中断开关A20地址线。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">in	al, <span class="number">92</span>h</span><br><span class="line"><span class="keyword">or</span> al, <span class="number">00000010b</span>    ;  | 打开 A20 地址线</span><br><span class="line">out	<span class="number">92</span>h, al</span><br><span class="line"></span><br><span class="line">in	al, <span class="number">92</span>h		</span><br><span class="line"><span class="keyword">and</span>	al, <span class="number">11111101b</span>	;  | 关闭 A20 地址线</span><br><span class="line">out	<span class="number">92</span>h, al</span><br></pre></td></tr></table></figure>
<h2 id="保护模式下的内存访问"><a href="#保护模式下的内存访问" class="headerlink" title="保护模式下的内存访问"></a>保护模式下的内存访问</h2><p><code>我不知道为什么会在这里介绍这个知识：CR0寄存器的最后一位就是保护模式和实模式的切换开关，置1进入保护模式</code></p>
<p>不同于8086的访问方式，32位处理器的段寄存器存放的不是段基址，而是段选择子。段选择子存储的是一个索引，当前段在段描述符表中的索引，和一些访问信息。</p>
<p><img src="/images/从实模式到保护模式/11_4.png" alt=""></p>
<p>TI=0时表示段描述符在GDT中，TI=1的时候表示在LDT中。RPL 是请求特权级，请求访问这个段的程序的特权级别。</p>
<p>事实上不是每次访问都会去表中查找，每个段寄存器有他自己的描述符高速缓存器，只有当改变了段选择子的时候才回去表中查找段描述符并且加载到高速缓存器中。以后每次都直接从高速缓存器中取得段描述符。</p>
<p>但实模式并没有GDT表和LDT表哦，所以实模式下改变段寄存器是将段基址左移四位然后送到高速缓存器低20位中。</p>
<h3 id="清空流水线并串行化处理器"><a href="#清空流水线并串行化处理器" class="headerlink" title="清空流水线并串行化处理器"></a>清空流水线并串行化处理器</h3><p><code>jmp的时候已经在流水线中执行了一部分的代码怎么处理?</code></p>
<p><code>汇编指令不具有原子性了?</code></p>
<p>设置CR0寄存器后，其实还有两个问题。</p>
<ol>
<li>段描述符高速缓存器中存的还是实模式的数据。</li>
<li>流水线中的代码和乱序执行未完成的代码可能因为是为了32bits环境编译的，在实模式16bits下译码就会出错。需要清空流水线并串行化处理器。</li>
</ol>
<p>有一个两全其美的方案</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jmp dword SelectorToProtectedModeCode:<span class="number">0</span></span><br><span class="line"></span><br><span class="line">PROTECTED_MODE_CODE:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>需要在全局描述符表中添加PROTECTED_MODE_CODE的描述符，jmp本身会清空流水线串行化处理器，这一条指令还会将SelectorToProtectedModeCode装载到cs中，就会更新高速缓存器，至此完全进入保护模式中。</p>
<p>用dword是为了严谨，因为jmp语句放在16bits的代码段中，但是目标代码段是32bits的，不用dword声明为32bits代码，偏移如果过大就会被截断。</p>
<h1 id="第十二章-存储器的保护"><a href="#第十二章-存储器的保护" class="headerlink" title="第十二章 存储器的保护"></a>第十二章 存储器的保护</h1><p>这一章开始对一个进入保护模式的示例代码进行讲解，有关保护模式的代码实现在《一个操作系统实现》的笔记中，此处略去相关内容。</p>
<h2 id="mov-ds-ax-和-mov-ds-eax"><a href="#mov-ds-ax-和-mov-ds-eax" class="headerlink" title="mov ds, ax 和 mov ds, eax"></a>mov ds, ax 和 mov ds, eax</h2><p>在32bits模式下，对于指令 mov ds, ax， 有些人认为操作数是16位的所以汇编出来的机器码应该加上0x66前缀。这样会浪费一个时钟周期，本书作者认为他们是傻逼，但是为了兼容他们，用 mov ds, eax 的指令来达到同样的效果但是生成的机器码没有0x66前缀。</p>
<h2 id="存储器保护"><a href="#存储器保护" class="headerlink" title="存储器保护"></a>存储器保护</h2><p>在为段寄存器赋值时，会检测是否超过描述符表边界。</p>
<p>在为特定的寄存器赋值时，会检测相关类别，例如只有可以写入的数据段才可以加载入SS段。这里有一个设计：除了CS和SS之外的段寄存器可以赋值0(<code>作者还没讲为什么</code>)。</p>
<h2 id="地址变换时的保护"><a href="#地址变换时的保护" class="headerlink" title="地址变换时的保护"></a>地址变换时的保护</h2><h3 id="代码段执行的保护"><a href="#代码段执行的保护" class="headerlink" title="代码段执行的保护"></a>代码段执行的保护</h3><p>当处理器在某个段内取指令执行时，会检测指令是否跨越了段边界。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 ≤ (EIP + 指令长度 - 1) ≤ 实际使用的段界限</span><br></pre></td></tr></table></figure>
<h3 id="桟操作时的保护"><a href="#桟操作时的保护" class="headerlink" title="桟操作时的保护"></a>桟操作时的保护</h3><p>同样的处理器在桟操作时也会检测。桟段通常属于向下扩展的，段界限的值同向上扩展的（段长度-1）有所不同，和粒度一起决定ESP所能具有的最小值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际使用的段界限 + 1 ≤ (ESP的内容 - 操作数的长度) ≤ 0XFFFFFFFF</span><br></pre></td></tr></table></figure>
<p><strong><code>为什么对高端地址没有限制？</code></strong> 因为是向下扩展的，桟段一般在内存顶部</p>
<p><strong><code>什么叫做实际使用的段界限就是段内不允许访问的最低端偏移地址</code></strong> 因为是向下扩展的，是定义</p>
<h3 id="数据访问时的保护"><a href="#数据访问时的保护" class="headerlink" title="数据访问时的保护"></a>数据访问时的保护</h3><p>和代码段没啥不同的，就是指令长度变为了操作数的长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 ≤ (EIP + 操作数长度 - 1) ≤ 实际使用的段界限</span><br></pre></td></tr></table></figure>
<h2 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h2><p>使用另外声明的操作符指向某个已存在的操作符指向的段，但是可以通过设置不同的类型达到例如写入代码段的功能。</p>
<h2 id="指令们"><a href="#指令们" class="headerlink" title="指令们"></a>指令们</h2><ul>
<li><code>xchg</code> 交换指令，交换两个操作数的内容。</li>
</ul>
<h1 id="第十三章-程序的动态加载和执行"><a href="#第十三章-程序的动态加载和执行" class="headerlink" title="第十三章 程序的动态加载和执行"></a>第十三章 程序的动态加载和执行</h1><p>学习目标：</p>
<ol>
<li>了解保护模式是为操作系统提供的技术，不会给应用程序编程带来负担。</li>
<li>学习操作系统在保护模式下加载和重定位应用程序的一般原理，学习简单的内存动态分配，了解应用程序接口API的简单原理，学习字符串比较算法。</li>
<li>学习新指令：bswap、cpuid、cmovcc、sgdt、movzx、movsx、cmpsb、cmpsw、cmpsd、xlat等。</li>
</ol>
<p>指令：</p>
<pre><code>bswap r32; 字节交换，改变字节序
cpuid; 获得cpu信息
cmovcc; 条件传送指令：避免跳转导致流水线清空，条件转移和传送指令结合的产物
sgdt; lgdt的反指令，获得GDTR内容
movzx r16(32), r/m8(16); 零扩展传送
movsx r16(32), r/m8(16); 符号扩展传送
cmpsb/sw/sd; 字节/字/双字 比较指令
xlat; 查表指令，用al寄存器内容作为ds:ebx(bx)表中偏移返回一字节传回al寄存器。
</code></pre><p>注：本章实现了一个小内核，能够加载执行用户应用程序。代码并未自己实现，主要对这个流程中内核的功能管中窥豹、点到为止。内核的实现也并不是当前操作系统的实现，甚至算不上一个内核。</p>
<h2 id="代码清单"><a href="#代码清单" class="headerlink" title="代码清单"></a>代码清单</h2><ol>
<li>13_1.asm 主引导扇区程序</li>
<li>13_2.asm 微型内核</li>
<li>13_3.asm 用户程序</li>
</ol>
<h2 id="内核的结构、功能和加载"><a href="#内核的结构、功能和加载" class="headerlink" title="内核的结构、功能和加载"></a>内核的结构、功能和加载</h2><h3 id="内核的结构"><a href="#内核的结构" class="headerlink" title="内核的结构"></a>内核的结构</h3><p>本章的例子中用到的内核的结构为：</p>
<ul>
<li><p>内核头部数据</p>
<p>  存放了一些内核长度长度、各个段位置信息，用于引导程序加载时创建内核的段描述符。</p>
</li>
<li><p>公用例程段</p>
<p>  提供了一些功能，可以自己使用也可以提供给用户程序使用。</p>
</li>
<li><p>内核数据段</p>
<p>  内核自己的数据段。</p>
</li>
<li><p>内核代码段</p>
<p>  内核的代码。</p>
</li>
<li><p>尾部</p>
<p>  计算内核长度。</p>
</li>
</ul>
<h3 id="内核的加载"><a href="#内核的加载" class="headerlink" title="内核的加载"></a>内核的加载</h3><p>引导程序首先划分内存，为内核程序划分足够的内存空间，例子中划分0x40000-0x9FFFF都是他的地盘。</p>
<pre><code>0X000A0000往上是ROM BIOS的空间。
</code></pre><p>引导程序建立各个描述符，然后进入32位保护模式，初始化各个段。这一步在前面的章节有提到过。</p>
<p>从约定位置（磁盘的第一扇区）读取内核，因为初始化不知道内核有多大，所以需要根据内核头部判是否还要继续读入其他扇区。</p>
<p>接下来是为内核建立段描述符，公用例程、核心数据段和核心代码段等。将接下来刷新GDTR的描述符表的界限。</p>
<pre><code>因为引导程序和操作系统是一家，所以示例代码中段选择子并没有由引导程序传入内核，而是在内核中声明了常数，这样其实不是很好。

由于lgdt（存放GDTR的内容）的地方在代码段中，但代码段不允许更改，于是用到了别名的方法，有一个4GB数据段描述符跨越了整个内存空间，因为是内核所以无敌！
</code></pre><p>最后通过一个长跳转指令就阔仪啦。</p>
<p><code>jmp far [m];是根据什么设置CS的？</code></p>
<h2 id="在内核中执行"><a href="#在内核中执行" class="headerlink" title="在内核中执行"></a>在内核中执行</h2><p>首先初始化段寄存器DS指向内核数据段，（<code>所以CS是怎么指过来的</code>）</p>
<h2 id="用户程序加载"><a href="#用户程序加载" class="headerlink" title="用户程序加载"></a>用户程序加载</h2><h3 id="用户程序的结构"><a href="#用户程序的结构" class="headerlink" title="用户程序的结构"></a>用户程序的结构</h3><p>用户程序必须要满足一定的结构才能方便内核程序加载时初始化。本例中用户程序结构如下：</p>
<ul>
<li><p>程序头部</p>
<p>  包含程序长度，头部长度，程序入口地址，各个段的信息。</p>
</li>
<li><p>符号地址检索表</p>
<p>  调用内核例程的跳转表。</p>
</li>
<li><p>数据段</p>
</li>
<li><p>代码段</p>
</li>
</ul>
<p>有一点WINDOWS的影子。</p>
<h3 id="计算扇区数"><a href="#计算扇区数" class="headerlink" title="计算扇区数"></a>计算扇区数</h3><p>算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[core_buf]                 ;程序尺寸</span><br><span class="line">mov ebx,eax</span><br><span class="line"><span class="keyword">and</span> ebx,<span class="number">0xfffffe00</span>                 ;使之<span class="number">512</span>字节对齐（能被<span class="number">512</span>整除的数， </span><br><span class="line">add ebx,<span class="number">512</span>                        ;低<span class="number">9</span>位都为<span class="number">0</span> </span><br><span class="line">test eax,<span class="number">0x000001ff</span>                ;程序的大小正好是<span class="number">512</span>的倍数吗? </span><br><span class="line">cmovnz eax,ebx                     ;不是。使用凑整的结果</span><br></pre></td></tr></table></figure>
<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><p>读取的应用程序需要分配内存存放，若应用程序申请内存，也需要分配内存。操作系统的内存分配特别复杂，这里暂时就不考虑应用程序申请内存。</p>
<p>维护一个内存指针，每次分配内存的时候就把指针作为内存首地址返回，然后把指针加上程序大小，还要考虑对齐。</p>
<h3 id="段的重定位和描述符的创建"><a href="#段的重定位和描述符的创建" class="headerlink" title="段的重定位和描述符的创建"></a>段的重定位和描述符的创建</h3><p>和加载内核程序类似。</p>
<p>这里有一个小技巧，为了获得GDT的总字节数，将获得的GDT界限加一，用的是指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inc bx</span><br><span class="line">;而不是</span><br><span class="line">inc ebx</span><br></pre></td></tr></table></figure>
<p>在加载过GDTR之后，这样用都是可以的，但是当刚开机时，还没有装载过GDTR。此时GDTR的值是0x00000000FFFF，因为长度为0，所以界限为FFFF，这个时候inc ebx的结果是0x00010000，这个作为偏移量显然不对。而inc bx的结果是0x00000000。</p>
<h3 id="重定位用户程序内的符号地址"><a href="#重定位用户程序内的符号地址" class="headerlink" title="重定位用户程序内的符号地址"></a>重定位用户程序内的符号地址</h3><p>不管是内核程序还是用户程序的重定位表前都有表长的数据，所以只要两层loop循环比较就好了，比较成功后将地址和段描述符直接载入用户程序原来存放符号名称的地方，这一点和WINDOWS我记得是相似的。</p>
<h1 id="第十四章-任务和特权级保护"><a href="#第十四章-任务和特权级保护" class="headerlink" title="第十四章 任务和特权级保护"></a>第十四章 任务和特权级保护</h1><p>学习目标：</p>
<ol>
<li>通过演示如何创建一个任务并使之投入运行来学习任务的概念及其组成要素，包括任务的全局空间和局部空间、TSS、LDT、特权级等。</li>
<li>必须了解特别级不是指任务的特权级，而是指组成任务的各个部分的特权级。</li>
<li>清楚CPL、DPL和RPL的含义，以及不同特权级的控制转移规则。</li>
<li>熟悉调用门的用法。</li>
<li>学习一些新指令：lldt、ltr、pushf/pushfd、popf/popfd、ret n/retf n、arpl等，同时了解jmp和call这样传统指令如何被赋予一些新功能。</li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/操作系统/" rel="tag"># 操作系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/15/游戏编程模式读书笔记/" rel="next" title="<游戏编程模式>笔记">
                <i class="fa fa-chevron-left"></i> <游戏编程模式>笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/09/18/HEXO+NGINX搭建博客教程/" rel="prev" title="Hexo+Nginx+Rsync博客搭建">
                Hexo+Nginx+Rsync博客搭建 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Lee</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/RLee063" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://douban.com/people/rlee063" target="_blank" title="豆瓣">
                      
                        <i class="fa fa-fw fa-grav"></i>豆瓣</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第十章-32位x86处理器编程架构"><span class="nav-number">1.</span> <span class="nav-text">第十章 32位x86处理器编程架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-IA-32架构的基本执行环境"><span class="nav-number">1.1.</span> <span class="nav-text">10.1 IA-32架构的基本执行环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-线代处理器的结构和特点"><span class="nav-number">1.2.</span> <span class="nav-text">10.2 线代处理器的结构和特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-1-流水线"><span class="nav-number">1.2.1.</span> <span class="nav-text">10.2.1 流水线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-2-cache高速缓存"><span class="nav-number">1.2.2.</span> <span class="nav-text">10.2.2 cache高速缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-3-乱序执行"><span class="nav-number">1.2.3.</span> <span class="nav-text">10.2.3 乱序执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-4-寄存器重命名"><span class="nav-number">1.2.4.</span> <span class="nav-text">10.2.4 寄存器重命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-5-分支目标预测"><span class="nav-number">1.2.5.</span> <span class="nav-text">10.2.5 分支目标预测</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-3-32位模式的指令系统"><span class="nav-number">1.3.</span> <span class="nav-text">10.3 32位模式的指令系统</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十一章-进入保护模式"><span class="nav-number">2.</span> <span class="nav-text">第十一章 进入保护模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#全局描述符表GDT"><span class="nav-number">2.1.</span> <span class="nav-text">全局描述符表GDT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储器的段描述符"><span class="nav-number">2.2.</span> <span class="nav-text">存储器的段描述符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装存储器的段描述符并加载GDTR"><span class="nav-number">2.3.</span> <span class="nav-text">安装存储器的段描述符并加载GDTR</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#A20地址线"><span class="nav-number">2.4.</span> <span class="nav-text">A20地址线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#保护模式下的内存访问"><span class="nav-number">2.5.</span> <span class="nav-text">保护模式下的内存访问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#清空流水线并串行化处理器"><span class="nav-number">2.5.1.</span> <span class="nav-text">清空流水线并串行化处理器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十二章-存储器的保护"><span class="nav-number">3.</span> <span class="nav-text">第十二章 存储器的保护</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#mov-ds-ax-和-mov-ds-eax"><span class="nav-number">3.1.</span> <span class="nav-text">mov ds, ax 和 mov ds, eax</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储器保护"><span class="nav-number">3.2.</span> <span class="nav-text">存储器保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#地址变换时的保护"><span class="nav-number">3.3.</span> <span class="nav-text">地址变换时的保护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代码段执行的保护"><span class="nav-number">3.3.1.</span> <span class="nav-text">代码段执行的保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#桟操作时的保护"><span class="nav-number">3.3.2.</span> <span class="nav-text">桟操作时的保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据访问时的保护"><span class="nav-number">3.3.3.</span> <span class="nav-text">数据访问时的保护</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用别名"><span class="nav-number">3.4.</span> <span class="nav-text">使用别名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指令们"><span class="nav-number">3.5.</span> <span class="nav-text">指令们</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十三章-程序的动态加载和执行"><span class="nav-number">4.</span> <span class="nav-text">第十三章 程序的动态加载和执行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#代码清单"><span class="nav-number">4.1.</span> <span class="nav-text">代码清单</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内核的结构、功能和加载"><span class="nav-number">4.2.</span> <span class="nav-text">内核的结构、功能和加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内核的结构"><span class="nav-number">4.2.1.</span> <span class="nav-text">内核的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内核的加载"><span class="nav-number">4.2.2.</span> <span class="nav-text">内核的加载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在内核中执行"><span class="nav-number">4.3.</span> <span class="nav-text">在内核中执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户程序加载"><span class="nav-number">4.4.</span> <span class="nav-text">用户程序加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用户程序的结构"><span class="nav-number">4.4.1.</span> <span class="nav-text">用户程序的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算扇区数"><span class="nav-number">4.4.2.</span> <span class="nav-text">计算扇区数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态内存分配"><span class="nav-number">4.4.3.</span> <span class="nav-text">动态内存分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#段的重定位和描述符的创建"><span class="nav-number">4.4.4.</span> <span class="nav-text">段的重定位和描述符的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重定位用户程序内的符号地址"><span class="nav-number">4.4.5.</span> <span class="nav-text">重定位用户程序内的符号地址</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十四章-任务和特权级保护"><span class="nav-number">5.</span> <span class="nav-text">第十四章 任务和特权级保护</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lee</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
