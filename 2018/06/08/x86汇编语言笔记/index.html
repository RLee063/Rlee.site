<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans" >
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="操作系统," />










<meta name="description" content="第十章 32位x86处理器编程架构10.1 IA-32架构的基本执行环境略 10.2 线代处理器的结构和特点10.2.1 流水线为了提高处理器的执行效率和速度，可以把一条指令的执行过程分解为若干个细小的步骤，并分配给相应的单元来完成。各个单元独立、并行执行，这种执行指令的方法就是流水线技术。  10.2.2 cache高速缓存高速缓存是处理器与内存之间的一个静态存储器，用于缓解处理器速度和内存读写">
<meta name="keywords" content="操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="&lt;从实模式到保护模式&gt;笔记">
<meta property="og:url" content="http://yoursite.com/2018/06/08/x86汇编语言笔记/index.html">
<meta property="og:site_name" content="Lee&#39;s site">
<meta property="og:description" content="第十章 32位x86处理器编程架构10.1 IA-32架构的基本执行环境略 10.2 线代处理器的结构和特点10.2.1 流水线为了提高处理器的执行效率和速度，可以把一条指令的执行过程分解为若干个细小的步骤，并分配给相应的单元来完成。各个单元独立、并行执行，这种执行指令的方法就是流水线技术。  10.2.2 cache高速缓存高速缓存是处理器与内存之间的一个静态存储器，用于缓解处理器速度和内存读写">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/10_1.png">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/10_2.png">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/10_3.png">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/11_1.png">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/11_2.png">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/11_3.png">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/11_5.png">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/11_4.png">
<meta property="og:image" content="http://yoursite.com/2018/06/08/images/从实模式到保护模式/14_1.png">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/14_2.png">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/14_3.png">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/14_4.png">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/14_5.png">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/14_6.png">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/14_7.png">
<meta property="og:image" content="http://yoursite.com/images/从实模式到保护模式/14_8.png">
<meta property="og:updated_time" content="2018-06-11T04:00:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="&lt;从实模式到保护模式&gt;笔记">
<meta name="twitter:description" content="第十章 32位x86处理器编程架构10.1 IA-32架构的基本执行环境略 10.2 线代处理器的结构和特点10.2.1 流水线为了提高处理器的执行效率和速度，可以把一条指令的执行过程分解为若干个细小的步骤，并分配给相应的单元来完成。各个单元独立、并行执行，这种执行指令的方法就是流水线技术。  10.2.2 cache高速缓存高速缓存是处理器与内存之间的一个静态存储器，用于缓解处理器速度和内存读写">
<meta name="twitter:image" content="http://yoursite.com/images/从实模式到保护模式/10_1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/08/x86汇编语言笔记/"/>





  <title><从实模式到保护模式>笔记 | Lee's site</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans" style="background-image: url(/images/bg1.jpeg); background-attachment: fixed ">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Lee's site</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/08/x86汇编语言笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Lee">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lee's site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"><从实模式到保护模式>笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-08T12:00:00+08:00">
                2018-06-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/学习笔记/" itemprop="url" rel="index">
                    <span itemprop="name">学习笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第十章-32位x86处理器编程架构"><a href="#第十章-32位x86处理器编程架构" class="headerlink" title="第十章 32位x86处理器编程架构"></a>第十章 32位x86处理器编程架构</h1><h2 id="10-1-IA-32架构的基本执行环境"><a href="#10-1-IA-32架构的基本执行环境" class="headerlink" title="10.1 IA-32架构的基本执行环境"></a>10.1 IA-32架构的基本执行环境</h2><p>略</p>
<h2 id="10-2-线代处理器的结构和特点"><a href="#10-2-线代处理器的结构和特点" class="headerlink" title="10.2 线代处理器的结构和特点"></a>10.2 线代处理器的结构和特点</h2><h3 id="10-2-1-流水线"><a href="#10-2-1-流水线" class="headerlink" title="10.2.1 流水线"></a>10.2.1 流水线</h3><p>为了提高处理器的执行效率和速度，可以把一条指令的执行过程分解为若干个细小的步骤，并分配给相应的单元来完成。各个单元独立、并行执行，这种执行指令的方法就是流水线技术。</p>
<p><img src="/images/从实模式到保护模式/10_1.png" alt=""></p>
<h3 id="10-2-2-cache高速缓存"><a href="#10-2-2-cache高速缓存" class="headerlink" title="10.2.2 cache高速缓存"></a>10.2.2 cache高速缓存</h3><p>高速缓存是处理器与内存之间的一个静态存储器，用于缓解处理器速度和内存读写速度不匹配的问题。<br>程序运行时往往具有空间局部性，频繁的访问相邻内存的指令和数据。利用这个特性可以把处理器正在访问的内存调出来放在高速缓存中，每次访问内存时首先从高速缓存中检索。</p>
<p><img src="/images/从实模式到保护模式/10_2.png" alt=""></p>
<p>有关高速缓存的更多知识，例如高速缓存算法以及不中惩罚，请移步《深入理解计算机系统》笔记。</p>
<h3 id="10-2-3-乱序执行"><a href="#10-2-3-乱序执行" class="headerlink" title="10.2.3 乱序执行"></a>10.2.3 乱序执行</h3><p><code>支持乱序执行，怎么保证指令的原子性？</code></p>
<p><code>实现上述流水线操作不需要拆分指令？</code></p>
<p>为了实现流水线操作，需要把指令拆分为更小的微操作（micro-operations），例如对寄存器进行操作、访问内存等。这样处理器在适当的时候乱序执行指令就可以提高处理器效率。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [mem1]</span><br><span class="line">shl eax, <span class="number">5</span></span><br><span class="line">add eax, [mem2]</span><br><span class="line">mov [mem3], eax</span><br></pre></td></tr></table></figure>
<p>第三条指令可以分解为从内存中读取mem2的数值，把eax加上这个数值两个微操作，在执行第二条指令的时候就可以提前从内存中读取mem2的数值。</p>
<h3 id="10-2-4-寄存器重命名"><a href="#10-2-4-寄存器重命名" class="headerlink" title="10.2.4 寄存器重命名"></a>10.2.4 寄存器重命名</h3><p><code>感觉这一个特性是为了乱序执行服务的</code></p>
<p><code>具体算法是怎么实现的？</code></p>
<p>处理器通过对寄存器换名的方式（<code>具体算法书上没有提到，好像是tomasulo算法</code>）来避免WAR（读后写）和WAW（写后写）带来的流水线停顿。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax, [mem1]</span><br><span class="line">shl eax, <span class="number">3</span></span><br><span class="line">mov [mem2], eax</span><br><span class="line">mov eax, [mem3]</span><br><span class="line">add eax, <span class="number">2</span></span><br><span class="line">mov [mem4], eax</span><br></pre></td></tr></table></figure>
<p>很明显前三条指令与后三条指令没有关系，但是因为使用了相同的寄存器所以后三条指令必须等待eax释放之后才能执行，通过对后三条指令eax寄存器换名的方式，就可以对上述代码乱序执行。</p>
<h3 id="10-2-5-分支目标预测"><a href="#10-2-5-分支目标预测" class="headerlink" title="10.2.5 分支目标预测"></a>10.2.5 分支目标预测</h3><p>流水线最大的问题就是代码中存在大量分支，例如if语句随时可能让指令流前往任意方向。当遇到转移指令时，后面已经进入流水线的指令都会失效，必须清空流水线，这个代价显然太大了，所以就需要对分支目标进行预测。</p>
<p>从统计学的角度来看，有些事情一旦出现，下一次出现的概率还是很大，例如while循环。在处理器内部，有一个小容量的分支目标缓存器，当处理器执行了一条分支语句之后，在缓存器中就会记录当前指令的地址，分支目标地址，以及本次预测分支的结果。下次再执行到这个分支，处理器就会通过缓存器中的对应条目，预测执行和上一次相同的分支。但如果预测失败了，那么清空流水线，刷新缓存器中的记录，这个代价就比较大。</p>
<p><img src="/images/从实模式到保护模式/10_3.png" alt=""></p>
<h2 id="10-3-32位模式的指令系统"><a href="#10-3-32位模式的指令系统" class="headerlink" title="10.3 32位模式的指令系统"></a>10.3 32位模式的指令系统</h2><p>略</p>
<h1 id="第十一章-进入保护模式"><a href="#第十一章-进入保护模式" class="headerlink" title="第十一章 进入保护模式"></a>第十一章 进入保护模式</h1><h2 id="全局描述符表GDT"><a href="#全局描述符表GDT" class="headerlink" title="全局描述符表GDT"></a>全局描述符表GDT</h2><p>分段模式下需要控制对段的访问，就需要记录下与段相关的信息，每一条记录这样信息的数据结构被称为段描述符（Segment Descriptor），为了存放这些描述符，需要在内存中开辟一个段描述符表。其中最主要的描述符表是全局描述符表（Global Descriptor Table），进入保护模式之前必须要定义全局描述符表。</p>
<p>在进入保护模式之前，处理器必须要知道全局描述符表的位置，为此专门有一个48位寄存器GDTR来存放全局描述符表的信息。</p>
<p><img src="/images/从实模式到保护模式/11_1.png" alt=""></p>
<p>边界数值等于表大小-1，也就是最后一个字节的偏移量。</p>
<p>因为在进入保护模式之前处理器寻址能力只有1MB，所以GDT定义在1MB空间以内，进入保护模式之后可以迁移。</p>
<h2 id="存储器的段描述符"><a href="#存储器的段描述符" class="headerlink" title="存储器的段描述符"></a>存储器的段描述符</h2><p>每个段描述符占八个字节。结构如下：</p>
<p><img src="/images/从实模式到保护模式/11_2.png" alt=""></p>
<p><code>地址被拆开了是历史遗留问题</code></p>
<p>G 位是粒度，用于解释段界限的含义。如果为0则段界限以byte为单位，如果为1则段界限以4kbytes为单位。</p>
<p>D/B 是默认操作数大小/默认桟指针大小或者上部边界。对于代码段，0表示16bits，1表示32bits。对于桟段指明了用SP还是用ESP，上部边界是0XFFFF还是0XFFFFFFFF。</p>
<p>L 是64位代码段标志。</p>
<p>AVL 是保留给软件的位。</p>
<p>P 是段存在位，即是否在内存中。</p>
<p>DPL 是特权级位，用于限制访问。</p>
<p>S 位指定描述符类型，0代表系统段，1代表数据段或者代码段。</p>
<p>TYPE 指示段的属性，数据段和代码段定义不同：</p>
<p><img src="/images/从实模式到保护模式/11_3.png" alt=""></p>
<p>X 代表是否可执行，E 代表数据扩展方向，W 代表是否可写，A 代表最近是否访问。C 代表是否为特权级依从的（是否是一致代码段），R 代表是否是可读的。</p>
<pre><code>个人理解一致非一致代码段就是用来保护系统内核代码的。

1.一致代码段：用户代码可以访问的内核代码，但是内核代码不允许访问用户代码。
2.非一致代码段：只允许同级代码段访问。
</code></pre><p><img src="/images/从实模式到保护模式/11_5.png" alt=""></p>
<h2 id="安装存储器的段描述符并加载GDTR"><a href="#安装存储器的段描述符并加载GDTR" class="headerlink" title="安装存储器的段描述符并加载GDTR"></a>安装存储器的段描述符并加载GDTR</h2><p>GDT的第一个描述符必须是空描述符，毕竟经常会出错把啥啥啥变为0x00000000。<br>lgdt 是把全局描述符表的信息装载到GDTR里面的汇编指令。</p>
<h2 id="A20地址线"><a href="#A20地址线" class="headerlink" title="A20地址线"></a>A20地址线</h2><p>进入保护模式之前还有一个历史遗留问题。</p>
<p>以前最多能访问1MB，只需要20个地址引脚，那么第21个地址引脚就会出现点问题。只有20根地址引脚的时候访问超过0XFFFFF的时候就会变为0x100000，但没有1的地址引脚啊，所以就变成0x0000了。现在有了这个引脚，解决方案暂时是令其衡为零。</p>
<p>可以通过92号中断开关A20地址线。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">in	al, <span class="number">92</span>h</span><br><span class="line"><span class="keyword">or</span> al, <span class="number">00000010b</span>    ;  | 打开 A20 地址线</span><br><span class="line">out	<span class="number">92</span>h, al</span><br><span class="line"></span><br><span class="line">in	al, <span class="number">92</span>h		</span><br><span class="line"><span class="keyword">and</span>	al, <span class="number">11111101b</span>	;  | 关闭 A20 地址线</span><br><span class="line">out	<span class="number">92</span>h, al</span><br></pre></td></tr></table></figure>
<h2 id="保护模式下的内存访问"><a href="#保护模式下的内存访问" class="headerlink" title="保护模式下的内存访问"></a>保护模式下的内存访问</h2><p><code>我不知道为什么会在这里介绍这个知识：CR0寄存器的最后一位就是保护模式和实模式的切换开关，置1进入保护模式</code></p>
<p>不同于8086的访问方式，32位处理器的段寄存器存放的不是段基址，而是段选择子。段选择子存储的是一个索引，当前段在段描述符表中的索引，和一些访问信息。</p>
<p><img src="/images/从实模式到保护模式/11_4.png" alt=""></p>
<p>TI=0时表示段描述符在GDT中，TI=1的时候表示在LDT中。RPL 是请求特权级，请求访问这个段的程序的特权级别。</p>
<p>事实上不是每次访问都会去表中查找，每个段寄存器有他自己的描述符高速缓存器，只有当改变了段选择子的时候才回去表中查找段描述符并且加载到高速缓存器中。以后每次都直接从高速缓存器中取得段描述符。</p>
<p>但实模式并没有GDT表和LDT表哦，所以实模式下改变段寄存器是将段基址左移四位然后送到高速缓次都直接从高速缓存器中取得段描述符。</p>
<p>但实模式并没有GDT表和LDT表哦，所以实模式下改变段寄存器是将段基址左移四位然后送到高速缓存器低20位中。</p>
<h3 id="清空流水线并串行化处理器"><a href="#清空流水线并串行化处理器" class="headerlink" title="清空流水线并串行化处理器"></a>清空流水线并串行化处理器</h3><p><code>jmp的时候已经在流水线中执行了一部分的代码怎么处理?</code></p>
<p><code>汇编指令不具有原子性了?</code></p>
<p>设置CR0寄存器后，其实还有两个问题。</p>
<ol>
<li>段描述符高速缓存器中存的还是实模式的数据。</li>
<li>流水线中的代码和乱序执行未完成的代码可能因为是为了32bits环境编译的，在实模式16bits下译码就会出错。需要清空流水线并串行化处理器。</li>
</ol>
<p>有一个两全其美的方案</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jmp dword SelectorToProtectedModeCode:<span class="number">0</span></span><br><span class="line"></span><br><span class="line">PROTECTED_MODE_CODE:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>需要在全局描述符表中添加PROTECTED_MODE_CODE的描述符，jmp本身会清空流水线串行化处理器，这一条指令还会将SelectorToProtectedModeCode装载到cs中，就会更新高速缓存器，至此完全进入保护模式中。</p>
<p>用dword是为了严谨，因为jmp语句放在16bits的代码段中，但是目标代码段是32bits的，不用dword声明为32bits代码，偏移如果过大就会被截断。</p>
<h1 id="第十二章-存储器的保护"><a href="#第十二章-存储器的保护" class="headerlink" title="第十二章 存储器的保护"></a>第十二章 存储器的保护</h1><p>这一章开始对一个进入保护模式的示例代码进行讲解，有关保护模式的代码实现在《一个操作系统实现》的笔记中，此处略去相关内容。</p>
<h2 id="mov-ds-ax-和-mov-ds-eax"><a href="#mov-ds-ax-和-mov-ds-eax" class="headerlink" title="mov ds, ax 和 mov ds, eax"></a>mov ds, ax 和 mov ds, eax</h2><p>在32bits模式下，对于指令 mov ds, ax， 有些人认为操作数是16位的所以汇编出来的机器码应该加上0x66前缀。这样会浪费一个时钟周期，本书作者认为他们是傻逼，但是为了兼容他们，用 mov ds, eax 的指令来达到同样的效果但是生成的机器码没有0x66前缀。</p>
<h2 id="存储器保护"><a href="#存储器保护" class="headerlink" title="存储器保护"></a>存储器保护</h2><p>在为段寄存器赋值时，会检测是否超过描述符表边界。</p>
<p>在为特定的寄存器赋值时，会检测相关类别，例如只有可以写入的数据段才可以加载入SS段。这里有一个设计：除了CS和SS之外的段寄存器可以赋值0(<code>作者还没讲为什么</code>)。</p>
<h2 id="地址变换时的保护"><a href="#地址变换时的保护" class="headerlink" title="地址变换时的保护"></a>地址变换时的保护</h2><h3 id="代码段执行的保护"><a href="#代码段执行的保护" class="headerlink" title="代码段执行的保护"></a>代码段执行的保护</h3><p>当处理器在某个段内取指令执行时，会检测指令是否跨越了段边界。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 ≤ (EIP + 指令长度 - 1) ≤ 实际使用的段界限</span><br></pre></td></tr></table></figure>
<h3 id="桟操作时的保护"><a href="#桟操作时的保护" class="headerlink" title="桟操作时的保护"></a>桟操作时的保护</h3><p>同样的处理器在桟操作时也会检测。桟段通常属于向下扩展的，段界限的值同向上扩展的（段长度-1）有所不同，和粒度一起决定ESP所能具有的最小值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实际使用的段界限 + 1 ≤ (ESP的内容 - 操作数的长度) ≤ 0XFFFFFFFF</span><br></pre></td></tr></table></figure>
<p><strong><code>为什么对高端地址没有限制？</code></strong> 因为是向下扩展的，桟段一般在内存顶部</p>
<p><strong><code>什么叫做实际使用的段界限就是段内不允许访问的最低端偏移地址</code></strong> 因为是向下扩展的，是定义</p>
<h3 id="数据访问时的保护"><a href="#数据访问时的保护" class="headerlink" title="数据访问时的保护"></a>数据访问时的保护</h3><p>和代码段没啥不同的，就是指令长度变为了操作数的长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 ≤ (EIP + 操作数长度 - 1) ≤ 实际使用的段界限</span><br></pre></td></tr></table></figure>
<h2 id="使用别名"><a href="#使用别名" class="headerlink" title="使用别名"></a>使用别名</h2><p>使用另外声明的操作符指向某个已存在的操作符指向的段，但是可以通过设置不同的类型达到例如写入代码段的功能。</p>
<h2 id="指令们"><a href="#指令们" class="headerlink" title="指令们"></a>指令们</h2><ul>
<li><code>xchg</code> 交换指令，交换两个操作数的内容。</li>
</ul>
<h1 id="第十三章-程序的动态加载和执行"><a href="#第十三章-程序的动态加载和执行" class="headerlink" title="第十三章 程序的动态加载和执行"></a>第十三章 程序的动态加载和执行</h1><p>学习目标：</p>
<ol>
<li>了解保护模式是为操作系统提供的技术，不会给应用程序编程带来负担。</li>
<li>学习操作系统在保护模式下加载和重定位应用程序的一般原理，学习简单的内存动态分配，了解应用程序接口API的简单原理，学习字符串比较算法。</li>
<li>学习新指令：bswap、cpuid、cmovcc、sgdt、movzx、movsx、cmpsb、cmpsw、cmpsd、xlat等。</li>
</ol>
<p>指令：</p>
<pre><code>bswap r32; 字节交换，改变字节序
cpuid; 获得cpu信息
cmovcc; 条件传送指令：避免跳转导致流水线清空，条件转移和传送指令结合的产物
sgdt; lgdt的反指令，获得GDTR内容
movzx r16(32), r/m8(16); 零扩展传送
movsx r16(32), r/m8(16); 符号扩展传送
cmpsb/sw/sd; 字节/字/双字 比较指令
xlat; 查表指令，用al寄存器内容作为ds:ebx(bx)表中偏移返回一字节传回al寄存器。
</code></pre><p>注：本章实现了一个小内核，能够加载执行用户应用程序。代码并未自己实现，主要对这个流程中内核的功能管中窥豹、点到为止。内核的实现也并不是当前操作系统的实现，甚至算不上一个内核。</p>
<h2 id="代码清单"><a href="#代码清单" class="headerlink" title="代码清单"></a>代码清单</h2><ol>
<li>13_1.asm 主引导扇区程序</li>
<li>13_2.asm 微型内核</li>
<li>13_3.asm 用户程序</li>
</ol>
<h2 id="内核的结构、功能和加载"><a href="#内核的结构、功能和加载" class="headerlink" title="内核的结构、功能和加载"></a>内核的结构、功能和加载</h2><h3 id="内核的结构"><a href="#内核的结构" class="headerlink" title="内核的结构"></a>内核的结构</h3><p>本章的例子中用到的内核的结构为：</p>
<ul>
<li><p>内核头部数据</p>
<p>  存放了一些内核长度长度、各个段位置信息，用于引导程序加载时创建内核的段描述符。</p>
</li>
<li><p>公用例程段</p>
<p>  提供了一些功能，可以自己使用也可以提供给用户程序使用。</p>
</li>
<li><p>内核数据段</p>
<p>  内核自己的数据段。</p>
</li>
<li><p>内核代码段</p>
<p>  内核的代码。</p>
</li>
<li><p>尾部</p>
<p>  计算内核长度。</p>
</li>
</ul>
<h3 id="内核的加载"><a href="#内核的加载" class="headerlink" title="内核的加载"></a>内核的加载</h3><p>引导程序首先划分内存，为内核程序划分足够的内存空间，例子中划分0x40000-0x9FFFF都是他的地盘。</p>
<pre><code>0X000A0000往上是ROM BIOS的空间。
</code></pre><p>引导程序建立各个描述符，然后进入32位保护模式，初始化各个段。这一步在前面的章节有提到过。</p>
<p>从约定位置（磁盘的第一扇区）读取内核，因为初始化不知道内核有多大，所以需要根据内核头部判是否还要继续读入其他扇区。</p>
<p>接下来是为内核建立段描述符，公用例程、核心数据段和核心代码段等。将接下来刷新GDTR的描述符表的界限。</p>
<pre><code>因为引导程序和操作系统是一家，所以示例代码中段选择子并没有由引导程序传入内核，而是在内核中声明了常数，这样其实不是很好。

由于lgdt（存放GDTR的内容）的地方在代码段中，但代码段不允许更改，于是用到了别名的方法，有一个4GB数据段描述符跨越了整个内存空间，因为是内核所以无敌！
</code></pre><p>最后通过一个长跳转指令就阔仪啦。</p>
<p><code>jmp far [m];是根据什么设置CS的？</code></p>
<h2 id="在内核中执行"><a href="#在内核中执行" class="headerlink" title="在内核中执行"></a>在内核中执行</h2><p>首先初始化段寄存器DS指向内核数据段，（<code>所以CS是怎么指过来的</code>）</p>
<h2 id="用户程序加载"><a href="#用户程序加载" class="headerlink" title="用户程序加载"></a>用户程序加载</h2><h3 id="用户程序的结构"><a href="#用户程序的结构" class="headerlink" title="用户程序的结构"></a>用户程序的结构</h3><p>用户程序必须要满足一定的结构才能方便内核程序加载时初始化。本例中用户程序结构如下：</p>
<ul>
<li><p>程序头部</p>
<p>  包含程序长度，头部长度，程序入口地址，各个段的信息。</p>
</li>
<li><p>符号地址检索表</p>
<p>  调用内核例程的跳转表。</p>
</li>
<li><p>数据段</p>
</li>
<li><p>代码段</p>
</li>
</ul>
<p>有一点WINDOWS的影子。</p>
<h3 id="计算扇区数"><a href="#计算扇区数" class="headerlink" title="计算扇区数"></a>计算扇区数</h3><p>算法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax,[core_buf]                 ;程序尺寸</span><br><span class="line">mov ebx,eax</span><br><span class="line"><span class="keyword">and</span> ebx,<span class="number">0xfffffe00</span>                 ;使之<span class="number">512</span>字节对齐（能被<span class="number">512</span>整除的数， </span><br><span class="line">add ebx,<span class="number">512</span>                        ;低<span class="number">9</span>位都为<span class="number">0</span> </span><br><span class="line">test eax,<span class="number">0x000001ff</span>                ;程序的大小正好是<span class="number">512</span>的倍数吗? </span><br><span class="line">cmovnz eax,ebx                     ;不是。使用凑整的结果</span><br></pre></td></tr></table></figure>
<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><p>读取的应用程序需要分配内存存放，若应用程序申请内存，也需要分配内存。操作系统的内存分配特别复杂，这里暂时就不考虑应用程序申请内存。</p>
<p>维护一个内存指针，每次分配内存的时候就把指针作为内存首地址返回，然后把指针加上程序大小，还要考虑对齐。</p>
<h3 id="段的重定位和描述符的创建"><a href="#段的重定位和描述符的创建" class="headerlink" title="段的重定位和描述符的创建"></a>段的重定位和描述符的创建</h3><p>和加载内核程序类似。</p>
<p>这里有一个小技巧，为了获得GDT的总字节数，将获得的GDT界限加一，用的是指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inc bx</span><br><span class="line">;而不是</span><br><span class="line">inc ebx</span><br></pre></td></tr></table></figure>
<p>在加载过GDTR之后，这样用都是可以的，但是当刚开机时，还没有装载过GDTR。此时GDTR的值是0x00000000FFFF，因为长度为0，所以界限为FFFF，这个时候inc ebx的结果是0x00010000，这个作为偏移量显然不对。而inc bx的结果是0x00000000。</p>
<h3 id="重定位用户程序内的符号地址"><a href="#重定位用户程序内的符号地址" class="headerlink" title="重定位用户程序内的符号地址"></a>重定位用户程序内的符号地址</h3><p>不管是内核程序还是用户程序的重定位表前都有表长的数据，所以只要两层loop循环比较就好了，比较成功后将地址和段描述符直接载入用户程序原来存放符号名称的地方，这一点和WINDOWS我记得是相似的。</p>
<h1 id="第十四章-任务和特权级保护"><a href="#第十四章-任务和特权级保护" class="headerlink" title="第十四章 任务和特权级保护"></a>第十四章 任务和特权级保护</h1><p>学习目标：</p>
<ol>
<li>通过演示如何创建一个任务并使之投入运行来学习任务的概念及其组成要素，包括任务的全局空间和局部空间、TSS、LDT、特权级等。</li>
<li>必须了解特别级不是指任务的特权级，而是指组成任务的各个部分的特权级。</li>
<li>清楚CPL、DPL和RPL的含义，以及不同特权级的控制转移规则。</li>
<li>熟悉调用门的用法。</li>
<li>学习一些新指令：lldt、ltr、pushf/pushfd、popf/popfd、ret n/retf n、arpl等，同时了解jmp和call这样传统指令如何被赋予一些新功能。</li>
</ol>
<h2 id="任务的隔离与特权级保护"><a href="#任务的隔离与特权级保护" class="headerlink" title="任务的隔离与特权级保护"></a>任务的隔离与特权级保护</h2><h3 id="LDT"><a href="#LDT" class="headerlink" title="LDT"></a>LDT</h3><p>既然涉及到任务，那么每个任务固然像内核一样拥有自己的代码段，数据段和桟段，所以有LDT(Local Descriptor Table)。LDT和GDT结构一致，不同之处在于，LDT只属于单个任务。<code>LDT的0号槽位有效，因为访问LDT的选择子TI位为1</code></p>
<p>为了追踪LDT处理器使用了LDTR寄存器存储当前任务LDT信息。</p>
<h3 id="TSS"><a href="#TSS" class="headerlink" title="TSS"></a>TSS</h3><p>在做任务切换时候，需要保存当前任务的寄存器状态等重要信息，这个区域叫做TSS(任务状态段)，32-Bit格式如下</p>
<p><img src="../images/从实模式到保护模式/14_1.png" alt=""></p>
<p>和LDT、GDT一样，处理器通过TR寄存器跟踪TSS。<code>注意不是TSSR</code></p>
<h3 id="特权级DPC、CPL和RPL"><a href="#特权级DPC、CPL和RPL" class="headerlink" title="特权级DPC、CPL和RPL"></a>特权级DPC、CPL和RPL</h3><p>CPL：当前特权等级，通常被存储在当前执行程序的cs上低2位。</p>
<p><code>有CPL并不等于代码所在段的特权级的情况，例如一致代码段</code></p>
<p>DPL：表示门或者段的特权等级，用来限制跨特权级访问，在段描述符中。</p>
<ul>
<li>对于数据段，TSS和调用门，DPL规定了访问的最低特权级。</li>
<li>对于非一致代码段，DPL规定了访问该段的指定特权级。</li>
<li>对于一致代码段，DPL规定了访问该段的最高特权级。</li>
</ul>
<p>RPL：请求特权级，在段选择子的低两位上，与DPL一起作为访问限制。</p>
<ul>
<li>RPL的引入主要是为了防止用户特权级程序通过传给操作系统自己无法访问的段选择子达到访问自己不能访问的数据的目的。</li>
<li>CPU在权限比较时会比较CPL和RPL是否同时满足。</li>
<li>操作系统在从应用程序接受选择子时会检测选择子RPL是否和CPL相同，不同则将RPL置为CPL。</li>
</ul>
<h2 id="内核程序的初始化"><a href="#内核程序的初始化" class="headerlink" title="内核程序的初始化"></a>内核程序的初始化</h2><h3 id="安装调用门"><a href="#安装调用门" class="headerlink" title="安装调用门"></a>安装调用门</h3><p>由于用户程序工作在较低的特权级别<code>通常为3级</code>，要想像之前那样调用操作系统提供的例程的话显然CPU是不会允许的，这个时候需要安装调用门，本质上是一个描述符，结构如下：</p>
<p><img src="/images/从实模式到保护模式/14_2.png" alt=""></p>
<ul>
<li>TYPE：用于标明门的类型，事实上门都是这个结构，1100表示调用门</li>
<li>P：有效位，通常是1，为0时调用会产生异常中断属于故障中断，中断返回后还会执行引起中断的命令</li>
</ul>
<p>通过调用门实现控制转移需要使用长跳转命令<code>jmp far &amp; call far</code>，注意<code>call far</code>会改变CPL而前者不会。</p>
<p>指令中的偏移量不会被使用，使用段基址（调用门描述符中的段选择子选择的段描述符中的段基址）+偏移（调用门描述符里的偏移）作为访问的地址。</p>
<p>调用门的DPL决定了能够使用它的最小权限级别，目的代码段的DPL决定了能够访问它的最大权限级别。</p>
<pre><code>目标代码段描述符的DPL ≤ max(CPL, RPL) ≤ 调用门描述符的DPL
</code></pre><p>使用例程段描述符和每个例程段内偏移构造调用门，并添加到GDT中去并将选择子写入C-SALT表中供程序重定位之后使用。</p>
<h2 id="加载用户程序并创建任务"><a href="#加载用户程序并创建任务" class="headerlink" title="加载用户程序并创建任务"></a>加载用户程序并创建任务</h2><h3 id="任务控制块和TCB链"><a href="#任务控制块和TCB链" class="headerlink" title="任务控制块和TCB链"></a>任务控制块和TCB链</h3><p>有时候操作系统想要跟踪到所有的任务，想实现更多的进程管理光依靠CPU提供的TSS是远远不够的，于是自定义了任务控制块（Task Control Block）数据结构，用来存储与任务相关的更多信息。为了跟踪到所有的任务，可以将每个任务的TCB用链表串起来。</p>
<p>在每次创建一个任务的时候，就创建任务的TCB并将其挂到TCB链上，在内核里维护一个tcb_chain指针用于指向第一个TCB。</p>
<h3 id="32位桟操作"><a href="#32位桟操作" class="headerlink" title="*32位桟操作"></a>*32位桟操作</h3><p>略</p>
<p>32位下桟操作32位，会将16位段寄存器零扩展为32位</p>
<h3 id="加载用户程序"><a href="#加载用户程序" class="headerlink" title="加载用户程序"></a>加载用户程序</h3><ul>
<li>为LDT分配内存</li>
<li>将LDT在TCB中登记</li>
<li>分配内存加载用户程序，将其信息填入TCB中</li>
</ul>
<h3 id="创建局部描述符表"><a href="#创建局部描述符表" class="headerlink" title="创建局部描述符表"></a>创建局部描述符表</h3><p><code>注意最开始LDT界限为长度0-1=0XFFFF，在增加表项后修改界限的时候切记使用16位寄存器，否则进位影响到其他位。</code></p>
<p>从TCB中获取程序信息，为程序的所有段创建描述符，并安装在LDT中。注意段描述符的DPL等级为3，段选择子的TI位为1，表示在LDT中查找，并且RPL都是3。</p>
<h3 id="重定位U-SALT表"><a href="#重定位U-SALT表" class="headerlink" title="重定位U-SALT表"></a>重定位U-SALT表</h3><p>需要将C-SALT中的段选择子复制到用户程序中，需要将RPL从0修改为3<code>供操作系统使用更改为供用户程序使用</code></p>
<h3 id="创建0、1和2特权级的桟"><a href="#创建0、1和2特权级的桟" class="headerlink" title="创建0、1和2特权级的桟"></a>创建0、1和2特权级的桟</h3><p>用户程序从3特权级的代码切换到内核例程1特权级的代码时，如果用的是<code>call far</code>，当前CPL会发生变化，需要切换特权级不同的桟，就需要为程序准备不同特权级的段。</p>
<p>桟需要登记在TSS和TCB中，注意初始地址是高端地址，因为桟是逆生长的。</p>
<p>登记在TCB中的桟选择子RPL应当设置为0。</p>
<h3 id="安装LDT描述符到GDT中"><a href="#安装LDT描述符到GDT中" class="headerlink" title="安装LDT描述符到GDT中"></a>安装LDT描述符到GDT中</h3><p>需要在GDT中创建LDT的描述符。<code>为啥</code></p>
<p><img src="/images/从实模式到保护模式/14_3.png" alt=""></p>
<p><strong>S=0,TYPE=0010</strong>表明这是一个LDT描述符。</p>
<h3 id="任务状态段TSS创建与安装"><a href="#任务状态段TSS创建与安装" class="headerlink" title="任务状态段TSS创建与安装"></a>任务状态段TSS创建与安装</h3><p>依次填写TSS各个位置。</p>
<p>顶上有一个区域叫做：<code>I/O映射基地址</code>，<strong>关于操作系统I/O接口授权在另一本书中探索。</strong></p>
<p>安装TSS描述符到GDT中，通过<code>call far &amp; jmp far</code>指令操作TSS描述符选择子的时候，处理器就会执行任务切换操作。</p>
<p>TSS的描述符TYPE=0x10B1，其他和LDT一样。</p>
<h2 id="用户程序的执行"><a href="#用户程序的执行" class="headerlink" title="用户程序的执行"></a>用户程序的执行</h2><h3 id="通过调用门实现控制转移"><a href="#通过调用门实现控制转移" class="headerlink" title="通过调用门实现控制转移"></a>通过调用门实现控制转移</h3><p>在通过<code>call far</code>指令通过调用门转移控制时操作流程是：</p>
<ol>
<li>使用新CPL选择新桟的桟选择子和栈指针</li>
<li>使用桟选择子读取桟描述符</li>
<li>检查桟描述符的特权级和类型</li>
<li>临时保存当前桟段SS和ESP</li>
<li>载入新的SS和ESP</li>
<li>将临时保存的SS和ESP压入新桟</li>
<li>根据调用门描述符中的“参数个数”从旧桟中复制参数到新桟中</li>
<li>将当前CS和EIP压入新桟</li>
<li>载入新CS和EIP</li>
</ol>
<p>在通过retf返回时的操作流程是：</p>
<ol>
<li>检查桟中的CS，根据RPL决定返回是否变更特权级</li>
<li>从当前桟取出CS和EIP，并对RPL特权级检查</li>
<li>如果retf带参数，则跳过相应参数（被调用者的桟）</li>
<li>如果要改变特权级，则需要读取桟中的SS和ESP切换到调用者的桟</li>
<li>如果retf带参数，则跳过相应参数（调用者的桟）</li>
<li>如果返回要改变特权级，检查DS、ES、FS和GS寄存器的内容，找到对应的描述符，弱有DPL&gt;调用者CPL的情况，则传输0给相应的段寄存器</li>
</ol>
<h3 id="进入特权级3的用户程序执行"><a href="#进入特权级3的用户程序执行" class="headerlink" title="进入特权级3的用户程序执行"></a>进入特权级3的用户程序执行</h3><p>事实上CPU并不允许直接从0特权级的全局空间控制转移到3特权级的空间，可以通过假装从调用门返回的方式。</p>
<p>使TR、LDTR指向用户任务，将用户任务的CS和EIP压入桟中，执行一个远返回指令。</p>
<h1 id="第十五章-任务切换"><a href="#第十五章-任务切换" class="headerlink" title="第十五章 任务切换"></a>第十五章 任务切换</h1><h2 id="任务切换前的设置"><a href="#任务切换前的设置" class="headerlink" title="任务切换前的设置"></a>任务切换前的设置</h2><p>前一章中，没有涉及到任务切换，直接从3特权级的任务开始执行，这是不必要的。事实上内核刚开始加载的时候，就应该会创建一些0特权级属于内核的任务，例如：任务管理器。</p>
<p>于是在切换任务之前，可以将当前内核作为第一个任务。内核的段描述符都存在于GDT中，不需要LDT，事实上LDT本就不是必须的。设置内核任务的TSS，并在GDT中安装TSS的描述符。然后将TSS选择子传送到TR中，处理器便能够识别到当前任务，会自动将对应TSS描述符B位置1。</p>
<h2 id="任务切换的方法"><a href="#任务切换的方法" class="headerlink" title="任务切换的方法"></a>任务切换的方法</h2><p>可以利用中断，在保护模式下不再用中断向量表，而是用中断描述符表IDT，类似于GDT和LDT。中断描述符表中可以是中断门，陷阱们和任务门。如果中断号对应的是任务门的话，就会进行任务切换，保存当前任务的现场，转到另一个任务去执行。</p>
<p><img src="/images/从实模式到保护模式/14_4.png" alt=""></p>
<p>中断处理过程和任务切换都需要用<code>iret</code>来返回，通过<code>EFLAGS</code>的NT位来表明当前任务是否嵌套于其他任务（是否由其他任务切换而来），来决定<code>iret</code>时是否要切换任务。嵌套的任务TSS中B位都为1。<br><code>任务切换就必须是嵌套的？</code></p>
<p>除了使用任务门，还可以通过call, jmp的方式进行任务切换，将操作数置为TSS选择子即可。</p>
<p>使用call发起的任务切换类似于中断发起的任务切换，是嵌套的。而jmp不会，并把旧任务TSS中B位清零。</p>
<p>任务是不可重进入的，TSS中B位不为0时，不能执行任务切换。</p>
<h2 id="call-jmp-iret指令发起的任务切换"><a href="#call-jmp-iret指令发起的任务切换" class="headerlink" title="call/jmp/iret指令发起的任务切换"></a>call/jmp/iret指令发起的任务切换</h2><p><img src="/images/从实模式到保护模式/14_5.png" alt=""></p>
<h1 id="第十六章-分页机制和动态页面分配"><a href="#第十六章-分页机制和动态页面分配" class="headerlink" title="第十六章 分页机制和动态页面分配"></a>第十六章 分页机制和动态页面分配</h1><h2 id="分页机制概述"><a href="#分页机制概述" class="headerlink" title="分页机制概述"></a>分页机制概述</h2><p>在页式内存管理系统中，页面的管理和分配是独立的，和分段以及段地址没有关系。操作系统所要做的，就是寻找空闲页面，把它分配给需要的段，并将页的物理地址填写到映射表内。</p>
<h2 id="页目录、页表和页"><a href="#页目录、页表和页" class="headerlink" title="页目录、页表和页"></a>页目录、页表和页</h2><p>4GB虚拟地址要想转换为物理地址，就必须要一个表来记录逻辑地址与物理地址的映射。假设有4GB逻辑内存，每一页4KB，就有1024*1024项，假设每一项4字节就需要4M的内存空间，每一个程序一来就用4M的内存空间在以前是不能被接受的，因为某种原因<code>共享的全局空间</code>，并不能对这个表进行动态扩充，为了解决这个问题，页目录出现了。</p>
<p>定义每一个页表有1024项分别映射到一个具体的物理页，页目录每一项分别对应一个页表，于是页目录只有1024项，由于之前的特殊原因只会要求第一级的映射表要健全，于是现在每个程序只需要首先建立4K的页目录就可以了，大大节约了宝贵的内存<code>虽然对于现在的内存来说是本末倒置</code>。</p>
<p><img src="/images/从实模式到保护模式/14_6.png" alt=""></p>
<p>有一个控制寄存器CR3，存放着当前任务页目录的物理地址。在TSS中有存放CR3信息的相关槽位。</p>
<p>页表和页目录也同样是普通的页，在程序执行完毕后应该被回收。</p>
<h2 id="地址变换的具体过程"><a href="#地址变换的具体过程" class="headerlink" title="地址变换的具体过程"></a>地址变换的具体过程</h2><p>先通过段选择子和偏移得到32位的逻辑地址</p>
<p>高10位作为页目录偏移定位页表，中10位作为页表偏移定位页，低12位作为页内偏移确定物理地址。</p>
<h2 id="在分页机制下工作"><a href="#在分页机制下工作" class="headerlink" title="在分页机制下工作"></a>在分页机制下工作</h2><p>因为所有页都是4KB对齐，页表也是页所以定位页表的基地址和定位页的基地址一样只需要20位，每一个页表项或页目录项占4字节32位，剩下的位用来记录额外信息：</p>
<p><img src="/images/从实模式到保护模式/14_7.png" alt=""></p>
<p><img src="/images/从实模式到保护模式/14_8.png" alt=""></p>
<ul>
<li>P：存在位，页表不存在则需要创建页表，页不存在则需要从磁盘调入</li>
<li>RW：读写位，0只读，1可读写</li>
<li>US：用户/管理位，为1时允许所有特权级访问，为0时只允许0，1，2的程序访问</li>
<li>PWT：页级通写位，和高速缓存有关</li>
<li>PCD：页级高速缓存禁止位</li>
<li>A：访问位，是否被访问过</li>
<li>D：脏位，指向的页表是否写入过数据</li>
<li>PAT：页属性表支持位</li>
<li>G：全局位，用来指示该表项所指向的页是否为全局性质，如果是，则会在高速缓存中一直保存</li>
<li>AVL：软件使用位</li>
</ul>
<p>在创建页目录表时，将页目录表的物理地址等级在它自己的最后一个目录项里，为了方便用线性地址访问页目录表自己<code>会浪费实际内存高端4MB内存</code>。</p>
<p>我们的内核占用内存低端1MB，换算过来就是一个页目录项和256个页表项。为页目录项和第一个页表分配地址并填写内容。</p>
<p>内容填写好之后将需要页目录基地址填入CR3寄存，CR3高20位填写基地址，低12位除了PCD,PWT之外都没有使用。</p>
<p>CR0的最高位PG位用来开启或关闭页功能。</p>
<h2 id="任务全局空间和局部空间的页面映射"><a href="#任务全局空间和局部空间的页面映射" class="headerlink" title="任务全局空间和局部空间的页面映射"></a>任务全局空间和局部空间的页面映射</h2><p>由于每一个程序拥有自己独立的4GB地址空间，于是按照之前的方式调用操作系统例程就会出现问题。</p>
<p>为了公平起见，将4GB地址分为高2GB和低2GB，低2GB是程序的私有空间，高2GB是全局空间。</p>
<p>把页目录表的上半部分用下半部分的值复制覆盖，仅仅修改页目录表是不够的，还需要修改例程段描述符，和移动GDT的位置。</p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>虚拟内存分配和先前一样，用一个指针记录可以分配内存的地址。（说过分页对以前的机制没有本质改变）只是需要在页目录和页表中添加对应的项目，和分配具体的物理页，并将回填到页目录和页表的对应位置。</p>
<p>页面位串查找的核心思想就是将物理内存的使用情况用位串表示，通过查找位串来查询页面的分配情况。</p>
<h2 id="分页or分段"><a href="#分页or分段" class="headerlink" title="分页or分段"></a>分页or分段</h2><p>分段机制可以扩大CPU访问内存的能力<code>但是在现在已经不再适用</code>。</p>
<p>分段机制还可以方便的实现程序段的浮动和重定位<code>其他方法可以实现</code>。</p>
<p>分段机制可以防止一个程序访问不属于他的段<code>段界限</code>，但在分页模式下不在某个程序的页目录下注册页面这个程序就永远也不可能访问到那个页。</p>
<h2 id="平坦模型"><a href="#平坦模型" class="headerlink" title="平坦模型"></a>平坦模型</h2><p>所有的段描述符使用的段基址为0，段界限都是0xFFFFFFFF。因为只用使用偏移量就可以达到4GB的寻址能力，这样编程序会方便很多，不用去拘泥于段的划分。</p>
<p>随之带来的程序浮动与重定位问题，需要操作程序提供支持<code>链接器与加载器</code>。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/操作系统/" rel="tag"># 操作系统</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/15/游戏编程模式读书笔记/" rel="next" title="<游戏编程模式>笔记">
                <i class="fa fa-chevron-left"></i> <游戏编程模式>笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/09/18/HEXO+NGINX搭建博客教程/" rel="prev" title="Hexo+Nginx+Rsyn网站搭建">
                Hexo+Nginx+Rsyn网站搭建 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Lee</p>
              <p class="site-description motion-element" itemprop="description">Computer technology sharing</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/RLee063" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://douban.com/people/rlee063" target="_blank" title="豆瓣">
                      
                        <i class="fa fa-fw fa-grav"></i>豆瓣</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第十章-32位x86处理器编程架构"><span class="nav-number">1.</span> <span class="nav-text">第十章 32位x86处理器编程架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-IA-32架构的基本执行环境"><span class="nav-number">1.1.</span> <span class="nav-text">10.1 IA-32架构的基本执行环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-线代处理器的结构和特点"><span class="nav-number">1.2.</span> <span class="nav-text">10.2 线代处理器的结构和特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-1-流水线"><span class="nav-number">1.2.1.</span> <span class="nav-text">10.2.1 流水线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-2-cache高速缓存"><span class="nav-number">1.2.2.</span> <span class="nav-text">10.2.2 cache高速缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-3-乱序执行"><span class="nav-number">1.2.3.</span> <span class="nav-text">10.2.3 乱序执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-4-寄存器重命名"><span class="nav-number">1.2.4.</span> <span class="nav-text">10.2.4 寄存器重命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-5-分支目标预测"><span class="nav-number">1.2.5.</span> <span class="nav-text">10.2.5 分支目标预测</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-3-32位模式的指令系统"><span class="nav-number">1.3.</span> <span class="nav-text">10.3 32位模式的指令系统</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十一章-进入保护模式"><span class="nav-number">2.</span> <span class="nav-text">第十一章 进入保护模式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#全局描述符表GDT"><span class="nav-number">2.1.</span> <span class="nav-text">全局描述符表GDT</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储器的段描述符"><span class="nav-number">2.2.</span> <span class="nav-text">存储器的段描述符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#安装存储器的段描述符并加载GDTR"><span class="nav-number">2.3.</span> <span class="nav-text">安装存储器的段描述符并加载GDTR</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#A20地址线"><span class="nav-number">2.4.</span> <span class="nav-text">A20地址线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#保护模式下的内存访问"><span class="nav-number">2.5.</span> <span class="nav-text">保护模式下的内存访问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#清空流水线并串行化处理器"><span class="nav-number">2.5.1.</span> <span class="nav-text">清空流水线并串行化处理器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十二章-存储器的保护"><span class="nav-number">3.</span> <span class="nav-text">第十二章 存储器的保护</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#mov-ds-ax-和-mov-ds-eax"><span class="nav-number">3.1.</span> <span class="nav-text">mov ds, ax 和 mov ds, eax</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储器保护"><span class="nav-number">3.2.</span> <span class="nav-text">存储器保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#地址变换时的保护"><span class="nav-number">3.3.</span> <span class="nav-text">地址变换时的保护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#代码段执行的保护"><span class="nav-number">3.3.1.</span> <span class="nav-text">代码段执行的保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#桟操作时的保护"><span class="nav-number">3.3.2.</span> <span class="nav-text">桟操作时的保护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据访问时的保护"><span class="nav-number">3.3.3.</span> <span class="nav-text">数据访问时的保护</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用别名"><span class="nav-number">3.4.</span> <span class="nav-text">使用别名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指令们"><span class="nav-number">3.5.</span> <span class="nav-text">指令们</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十三章-程序的动态加载和执行"><span class="nav-number">4.</span> <span class="nav-text">第十三章 程序的动态加载和执行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#代码清单"><span class="nav-number">4.1.</span> <span class="nav-text">代码清单</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内核的结构、功能和加载"><span class="nav-number">4.2.</span> <span class="nav-text">内核的结构、功能和加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内核的结构"><span class="nav-number">4.2.1.</span> <span class="nav-text">内核的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内核的加载"><span class="nav-number">4.2.2.</span> <span class="nav-text">内核的加载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在内核中执行"><span class="nav-number">4.3.</span> <span class="nav-text">在内核中执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户程序加载"><span class="nav-number">4.4.</span> <span class="nav-text">用户程序加载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#用户程序的结构"><span class="nav-number">4.4.1.</span> <span class="nav-text">用户程序的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算扇区数"><span class="nav-number">4.4.2.</span> <span class="nav-text">计算扇区数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态内存分配"><span class="nav-number">4.4.3.</span> <span class="nav-text">动态内存分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#段的重定位和描述符的创建"><span class="nav-number">4.4.4.</span> <span class="nav-text">段的重定位和描述符的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重定位用户程序内的符号地址"><span class="nav-number">4.4.5.</span> <span class="nav-text">重定位用户程序内的符号地址</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十四章-任务和特权级保护"><span class="nav-number">5.</span> <span class="nav-text">第十四章 任务和特权级保护</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#任务的隔离与特权级保护"><span class="nav-number">5.1.</span> <span class="nav-text">任务的隔离与特权级保护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LDT"><span class="nav-number">5.1.1.</span> <span class="nav-text">LDT</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TSS"><span class="nav-number">5.1.2.</span> <span class="nav-text">TSS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特权级DPC、CPL和RPL"><span class="nav-number">5.1.3.</span> <span class="nav-text">特权级DPC、CPL和RPL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内核程序的初始化"><span class="nav-number">5.2.</span> <span class="nav-text">内核程序的初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#安装调用门"><span class="nav-number">5.2.1.</span> <span class="nav-text">安装调用门</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#加载用户程序并创建任务"><span class="nav-number">5.3.</span> <span class="nav-text">加载用户程序并创建任务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#任务控制块和TCB链"><span class="nav-number">5.3.1.</span> <span class="nav-text">任务控制块和TCB链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#32位桟操作"><span class="nav-number">5.3.2.</span> <span class="nav-text">*32位桟操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#加载用户程序"><span class="nav-number">5.3.3.</span> <span class="nav-text">加载用户程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建局部描述符表"><span class="nav-number">5.3.4.</span> <span class="nav-text">创建局部描述符表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重定位U-SALT表"><span class="nav-number">5.3.5.</span> <span class="nav-text">重定位U-SALT表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建0、1和2特权级的桟"><span class="nav-number">5.3.6.</span> <span class="nav-text">创建0、1和2特权级的桟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安装LDT描述符到GDT中"><span class="nav-number">5.3.7.</span> <span class="nav-text">安装LDT描述符到GDT中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#任务状态段TSS创建与安装"><span class="nav-number">5.3.8.</span> <span class="nav-text">任务状态段TSS创建与安装</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户程序的执行"><span class="nav-number">5.4.</span> <span class="nav-text">用户程序的执行</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通过调用门实现控制转移"><span class="nav-number">5.4.1.</span> <span class="nav-text">通过调用门实现控制转移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进入特权级3的用户程序执行"><span class="nav-number">5.4.2.</span> <span class="nav-text">进入特权级3的用户程序执行</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十五章-任务切换"><span class="nav-number">6.</span> <span class="nav-text">第十五章 任务切换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#任务切换前的设置"><span class="nav-number">6.1.</span> <span class="nav-text">任务切换前的设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#任务切换的方法"><span class="nav-number">6.2.</span> <span class="nav-text">任务切换的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#call-jmp-iret指令发起的任务切换"><span class="nav-number">6.3.</span> <span class="nav-text">call/jmp/iret指令发起的任务切换</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十六章-分页机制和动态页面分配"><span class="nav-number">7.</span> <span class="nav-text">第十六章 分页机制和动态页面分配</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#分页机制概述"><span class="nav-number">7.1.</span> <span class="nav-text">分页机制概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#页目录、页表和页"><span class="nav-number">7.2.</span> <span class="nav-text">页目录、页表和页</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#地址变换的具体过程"><span class="nav-number">7.3.</span> <span class="nav-text">地址变换的具体过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在分页机制下工作"><span class="nav-number">7.4.</span> <span class="nav-text">在分页机制下工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#任务全局空间和局部空间的页面映射"><span class="nav-number">7.5.</span> <span class="nav-text">任务全局空间和局部空间的页面映射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存分配"><span class="nav-number">7.6.</span> <span class="nav-text">内存分配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分页or分段"><span class="nav-number">7.7.</span> <span class="nav-text">分页or分段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#平坦模型"><span class="nav-number">7.8.</span> <span class="nav-text">平坦模型</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lee</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="http://www.miitbeian.gov.cn">蜀ICP备18030477</a> 强力驱动</div>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
